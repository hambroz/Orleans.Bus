<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

namespace Orleans.Bus
{
    /// <summary>
    /// Base class for all kinds of message based grains
    /// </summary>
    public abstract class MessageBasedGrain : GrainBase, IGrain, IGrainInstance
    {
<#@ include file="GrainCommon.cs" #>
	}

    /// <summary>
    /// Base class for all kinds of persistent message based grains
    /// </summary>
    public abstract class MessageBasedGrain<TState> : GrainBase<TState>, IGrain, IGrainInstance 
        where TState : class, IGrainState
    {
<#@ include file="GrainCommon.cs" #>
        
		TState explicitState;

        /// <summary>
        /// Gets or sets grain's state
        /// </summary>
        /// <remarks>You can use setter for testing purposes</remarks>
        public new TState State
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return explicitState ?? base.State; }
            set { explicitState = value; }
        }
	}

<#string[] ids = new string[]{"Guid", "Int64", "String"};#>
<#foreach (var id in ids) {#>
    /// <summary>
    /// Base class for message based grains identifiable by <see cref="<#= id #>"/> identifier
    /// </summary>
    public abstract class MessageBasedGrainWith<#= id #>Id : MessageBasedGrain, IHave<#= id #>Id
    {
        /// <summary>
        /// Gets identifier of the current grain.
        /// </summary>
        /// <returns><see cref="<#= id #>"/> identifier</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected <#= id #> Id()
        {
            return Runtime.Id(this);
        }
    }

<#}#>
<#foreach (var id in ids) {#>
    /// <summary>
    /// Base class for persistent message based grains identifiable by <see cref="<#= id #>"/> identifier
    /// </summary>
    public abstract class MessageBasedGrainWith<#= id #>Id<TState> : MessageBasedGrain<TState>, IHave<#= id #>Id
	        where TState : class, IGrainState
    {
        /// <summary>
        /// Gets identifier of the current grain.
        /// </summary>
        /// <returns><see cref="<#= id #>"/> identifier</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected <#= id #> Id()
        {
            return Runtime.Id(this);
        }
    }

<#}#>
    /// <summary>
    /// Base class for all kinds of observable message based grains
    /// </summary>
    public abstract class ObservableMessageBasedGrain : MessageBasedGrain, IObservableGrain
    {
<#@ include file="ObservableGrainCommon.cs" #>
    }

    /// <summary>
    /// Base class for all kinds of persitent observable message based grains
    /// </summary>
    public abstract class ObservableMessageBasedGrain<TGrainState> : MessageBasedGrain<TGrainState>, IObservableGrain
        where TGrainState : class, IGrainState
    {
<#@ include file="ObservableGrainCommon.cs" #>
    }

<#foreach (var id in ids) {#>
    /// <summary>
    /// Base class for observable message based grains identifiable by <see cref="<#= id #>"/> identifier
    /// </summary>
    public abstract class ObservableMessageBasedGrainWith<#= id #>Id : ObservableMessageBasedGrain, IHave<#= id #>Id
    {
        /// <summary>
        /// Notifies all attached observers registered for a particular type of event,
		/// passing given event to each of them.
        /// </summary>
        /// <typeparam name="TEvent">The type of event</typeparam>
        /// <param name="e">The event of <typeparamref name="TEvent"/> type</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void Notify<TEvent>(TEvent e)
        {
            Observers.Notify(Runtime.Id(this), e);
        }
    }

<#}#>
<#foreach (var id in ids) {#>
    /// <summary>
    /// Base class for persistent observable message based grains identifiable by <see cref="<#= id #>"/> identifier
    /// </summary>
    public abstract class ObservableMessageBasedGrainWith<#= id #>Id<TGrainState> : ObservableMessageBasedGrain<TGrainState>, IHave<#= id #>Id
        where TGrainState : class, IGrainState
    {
	    /// <summary>
        /// Notifies all attached observers registered for a particular type of event,
		/// passing given event to each of them.
        /// </summary>
        /// <typeparam name="TEvent">The type of event</typeparam>
        /// <param name="e">The event of <typeparamref name="TEvent"/> type</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void Notify<TEvent>(TEvent e)
        {
            Observers.Notify(Runtime.Id(this), e);
        }
    }

<#}#>
    /// <summary>
    /// This interface exists solely for unit testing purposes
    /// </summary>
    public interface IGrainInstance
    {
        /// <summary>
        /// Registers a timer to send periodic callbacks to this grain.
        /// 
        /// </summary>
        /// 
        /// <remarks>
        /// 
        /// <para>
        /// This timer will not prevent the current grain from being deactivated.
        ///             If the grain is deactivated, then the timer will be discarded.
        /// 
        /// </para>
        /// 
        /// <para>
        /// Until the Task returned from the asyncCallback is resolved,
        ///             the next timer tick will not be scheduled.
        ///             That is to say, timer callbacks never interleave their turns.
        /// 
        /// </para>
        /// 
        /// <para>
        /// The timer may be stopped at any time by calling the <c>Dispose</c> method
        ///             on the timer handle returned from this call.
        /// 
        /// </para>
        /// 
        /// <para>
        /// Any exceptions thrown by or faulted Task's returned from the asyncCallback
        ///             will be logged, but will not prevent the next timer tick from being queued.
        /// 
        /// </para>
        /// 
        /// </remarks>
        /// <param name="asyncCallback">Callback function to be invoked when timr ticks.</param>
        /// <param name="state">State object that will be passed as argument when calling the asyncCallback.</param>
        /// <param name="dueTime">Due time for first timer tick.</param>
        /// <param name="period">Period of subsequent timer ticks.</param>
        /// <returns>
        /// Handle for this Timer.
        /// </returns>
        /// <seealso cref="T:Orleans.IOrleansTimer"/>
        IOrleansTimer RegisterTimer(Func<object, Task> asyncCallback, object state, TimeSpan dueTime, TimeSpan period);
        
		/// <summary>
        /// Registers a persistent, reliable reminder to send regular notifications (reminders) to the grain.
        ///             The grain must implement the <c>Orleans.IRemindable</c> interface, and reminders for this grain will be sent to the <c>ReceiveReminder</c> callback method.
        ///             If the current grain is deactivated when the timer fires, a new activation of this grain will be created to receive this reminder.
        ///             If an existing reminder with the same name already exists, that reminder will be overwritten with this new reminder.
        ///             Reminders will always be received by one activation of this grain, even if multiple activations exist for this grain.
        /// 
        /// </summary>
        /// <param name="reminderName">Name of this reminder</param>
        /// <param name="dueTime">Due time for this reminder</param>
        /// <param name="period">Frequence period for this reminder</param>
        /// <returns>
        /// Promise for Reminder handle.
        /// </returns>
        Task<IOrleansReminder> RegisterOrUpdateReminder(string reminderName, TimeSpan dueTime, TimeSpan period);

        /// <summary>
        /// Unregisters a previously registered reminder.
        /// 
        /// </summary>
        /// <param name="reminder">Reminder to unregister.</param>
        /// <returns>
        /// Completion promise for this operation.
        /// </returns>
        Task UnregisterReminder(IOrleansReminder reminder);

        /// <summary>
        /// Returns a previously registered reminder.
        /// 
        /// </summary>
        /// <param name="reminderName">Reminder to return</param>
        /// <returns>
        /// Promise for Reminder handle.
        /// </returns>
        Task<IOrleansReminder> GetReminder(string reminderName);
		
        /// <summary>
        /// Returns a list of all reminders registered by the grain.
        /// 
        /// </summary>
        /// 
        /// <returns>
        /// Promise for list of Reminders registered for this grain.
        /// </returns>
        Task<List<IOrleansReminder>> GetReminders();

        /// <summary>
        /// Deactivate this activation of the grain after the current grain method call is completed.
        ///             This call will mark this activation of the current grain to be deactivated and removed at the end of the current method.
        ///             The next call to this grain will result in a different activation to be used, which typical means a new activation will be created automatically by the runtime.
        /// 
        /// </summary>
        void DeactivateOnIdle();

        /// <summary>
        /// Delay Deactivation of this activation at least for the specified time duration.
        ///             A positive <c>timeSpan</c> value means “prevent GC of this activation for that time span”.
        ///             A negative <c>timeSpan</c> value means “unlock, and make this activation available for GC again”.
        ///             DeactivateOnIdle method would undo / override any current “keep alive” setting,
        ///             making this grain immediately available  for deactivation.
        /// 
        /// </summary>
        void DelayDeactivation(TimeSpan timeSpan);
    }
}